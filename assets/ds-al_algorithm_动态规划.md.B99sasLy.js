import{_ as e,c as d,o as l,ah as o}from"./chunks/framework.BrJYEL96.js";const p=JSON.parse('{"title":"动态规划","description":"","frontmatter":{},"headers":[],"relativePath":"ds-al/algorithm/动态规划.md","filePath":"ds-al/algorithm/动态规划.md","lastUpdated":1750908320000}'),a={name:"ds-al/algorithm/动态规划.md"};function i(s,t,c,n,r,f){return l(),d("div",null,t[0]||(t[0]=[o('<h1 id="动态规划" tabindex="-1">动态规划 <a class="header-anchor" href="#动态规划" aria-label="Permalink to &quot;动态规划&quot;">​</a></h1><h3 id="经典动态规划问题" tabindex="-1">经典动态规划问题 <a class="header-anchor" href="#经典动态规划问题" aria-label="Permalink to &quot;经典动态规划问题&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">问题</th><th style="text-align:left;">状态定义</th><th style="text-align:left;">状态转移方程</th><th style="text-align:left;">初始化</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>斐波那契数列</strong></td><td style="text-align:left;"><code>dp[i]</code> 表示 <code>F(i)</code></td><td style="text-align:left;"><code>dp[i] = dp[i-1] + dp[i-2]</code></td><td style="text-align:left;"><code>dp[0] = 0</code>, <code>dp[1] = 1</code></td></tr><tr><td style="text-align:left;"><strong>爬楼梯</strong></td><td style="text-align:left;"><code>dp[i]</code> 表示到第 <code>i</code> 阶的方法数</td><td style="text-align:left;"><code>dp[i] = dp[i-1] + dp[i-2]</code></td><td style="text-align:left;"><code>dp[0] = 1</code>, <code>dp[1] = 1</code></td></tr><tr><td style="text-align:left;"><strong>解码方式</strong></td><td style="text-align:left;"><code>dp[i]</code> 表示前 <code>i</code> 个字符的解码方式数</td><td style="text-align:left;"><code>dp[i] = dp[i-1] (if s[i] valid) + dp[i-2] (if s[i-1..i] valid)</code></td><td style="text-align:left;"><code>dp[0] = 1</code></td></tr><tr><td style="text-align:left;"><strong>最长递增子序列（LIS）</strong></td><td style="text-align:left;"><code>dp[i]</code> 表示以 <code>nums[i]</code> 结尾的 LIS 长度</td><td style="text-align:left;"><code>dp[i] = max(dp[j] + 1) for j &lt; i if nums[j] &lt; nums[i]</code></td><td style="text-align:left;"><code>dp[i] = 1</code>（初始每个元素单独成序列）</td></tr><tr><td style="text-align:left;"><strong>0-1 背包问题</strong></td><td style="text-align:left;"><code>dp[i][j]</code> 表示前 <code>i</code> 个物品在容量 <code>j</code> 时的最大价值</td><td style="text-align:left;"><code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])</code></td><td style="text-align:left;"></td></tr></tbody></table>',3)]))}const x=e(a,[["render",i]]);export{p as __pageData,x as default};
